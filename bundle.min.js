!function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,(function(r){return o(e[i][1][r]||r)}),p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}({1:[function(require,module,exports){const{valueScope:valueScope}=require("./scope.js"),{tracker:tracker}=require("./parsing/errors.js"),{Expression:Expression,AssignExpression:AssignExpression,CallExpression:CallExpression,NameExpression:NameExpression,NumberExpression:NumberExpression,OperatorExpression:OperatorExpression,PrefixExpression:PrefixExpression}=require("./parsing/pratt/expressions.js"),{TokenType:TokenType}=require("./parsing/pratt/tokentype.js"),{complex:complex,Complex:Complex}=require("./math/complex.js");class Evaluatable{constructor(ast,args=null){this.ast=ast,this.args=null===args?[]:args}call(args){for(const arg of this.args)if(void 0===args[arg])return tracker.error(`function requires argument ${arg}`),null;try{return this._call(this.ast,args)}catch(error){return tracker.error(`An unrecognized error has occurred: ${error.message}`),null}}_call(ast,args=null){if(args=null===args?{}:args,ast instanceof OperatorExpression){const arg1=this._call(ast.mLeft,args),arg2=this._call(ast.mRight,args);switch(ast.mOperator){case TokenType.PLUS:return Complex.add(arg1,arg2);case TokenType.MINUS:return Complex.sub(arg1,arg2);case TokenType.ASTERISK:return Complex.mult(arg1,arg2);case TokenType.SLASH:return Complex.div(arg1,arg2);case TokenType.CARET:return Complex.pow(arg1,arg2);default:return tracker.error("unexpected operator encountered"),null}}else if(ast instanceof PrefixExpression){const arg1=this._call(ast.mRight,args);if(ast.mOperator===TokenType.MINUS)return arg1.scale(-1);tracker.error("unexpected prefix operator encountered")}else if(ast instanceof CallExpression){const functionArgs=ast.mArgs.map((arg=>this._call(arg,args)));if(void 0!==valueScope[ast.mFunction]){const func=valueScope[ast.mFunction];if(func instanceof Evaluatable){const argMap={};return func.args.forEach(((key,index)=>argMap[key]=functionArgs[index])),func.call(argMap)}return func(...functionArgs)}tracker.error(`could not resolve function ${ast.mFunction}. Note: higher order functions are not yet supported`)}else{if(ast instanceof NameExpression){if(void 0!==args[ast.mName])return args[ast.mName];if(void 0!==valueScope[ast.mName]){let value=valueScope[ast.mName];return value instanceof Evaluatable&&(value=value.call()),value}return tracker.error(`could not resolve variable ${ast.mName}`),null}if(ast instanceof NumberExpression)return complex(ast.mNumber,0);tracker.error("what is even going on")}}}module.exports={evaluate:function(ast){if(ast instanceof AssignExpression){const left=ast.mLeft;return left instanceof CallExpression?valueScope[left.mFunction.mName]=new Evaluatable(ast.mRight,left.mArgs.map((arg=>arg instanceof OperatorExpression?arg.mLeft.mName:arg.mName))):valueScope[left.mName]=new Evaluatable(ast.mRight),null}return new Evaluatable(ast)},Evaluatable:Evaluatable}},{"./math/complex.js":2,"./parsing/errors.js":9,"./parsing/pratt/expressions.js":12,"./parsing/pratt/tokentype.js":18,"./scope.js":20}],2:[function(require,module,exports){const pValues=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];class Complex{constructor(real,imaginary){this.re=real,this.im=imaginary}conj(){return new Complex(this.re,-this.im)}norm(){return Math.sqrt(this.re*this.re+this.im*this.im)}normSq(){return this.re*this.re+this.im*this.im}arg(){return(Math.atan2(this.im,this.re)+2*Math.PI)%(2*Math.PI)}unit(){return this.scale(1/this.norm())}scale(k){return new Complex(this.re*k,this.im*k)}add(z){return new Complex(this.re+z.re,this.im+z.im)}sub(z){return new Complex(this.re-z.re,this.im-z.im)}mult(z){return new Complex(this.re*z.re-this.im*z.im,this.re*z.im+this.im*z.re)}eMult(z){return new Complex(this.re*z.re,this.im*z.im)}inv(){return this.conj().scale(1/this.normSq())}div(z){return this.mult(z.inv())}perp(){return new Complex(-this.im,this.re)}sqrt(){const normSqrt=Math.sqrt(this.norm()),halfArg=.5*this.arg();return new Complex(normSqrt*Math.cos(halfArg),normSqrt*Math.sin(halfArg))}square(){return new Complex(this.re*this.re-this.im*this.im,2*this.re*this.im)}exp(){const mag=Math.exp(this.re);return new Complex(mag*Math.cos(this.im),mag*Math.sin(this.im))}ln(){return new Complex(Math.log(this.norm()),this.arg())}acos(){this.add(this.square().sub(new Complex(1,0)).sqrt()).ln().div(complex(0,1))}rotate(angle){return this.mult(new Complex(0,angle).exp())}dot(z){return this.re*z.re+this.im*z.im}angleTo(z){return Math.acos(this.dot(z)/(this.norm()*z.norm()))}toString(){return`(${this.re},${this.im})`}toLatex(){return`\\left(${roundTo(this.re,3)},${roundTo(this.im,3)}\\right)`}equals(z){return this.re==z.re&&this.im==z.im}equalsEps(z){return Math.abs(this.re-z.re)<1e-6&&Math.abs(this.im-z.im)<1e-6}mobius(a,b,c,d){if(Complex.infinite(this))return 0!==c?Complex.div(a,c):new Complex(1/0,1/0);{const denominator=Complex.add(Complex.mult(c,this),d);if(0===denominator)return new Complex(1/0,1/0);{const numerator=Complex.add(Complex.mult(a,this),b);return Complex.div(numerator,denominator)}}}sin(){const i=complex(0,1),rotated=this.mult(i);return rotated.exp().sub(rotated.scale(-1).exp()).div(i.scale(2))}cos(){const i=complex(0,1),rotated=this.mult(i);return rotated.exp().add(rotated.scale(-1).exp()).scale(.5)}tan(){return this.sin().div(this.cos())}sinh(){return this.exp().sub(this.scale(-1).exp()).scale(.5)}cosh(){return this.exp().add(this.scale(-1).exp()).scale(.5)}tanh(){return this.sinh().div(this.cosh())}pow(z){if(this.equalsEps(complex(0,0)))return z.equalsEps(complex(1,0))?complex(1,0):complex(0,0);const subAng=Math.atan2(this.im,this.re),normSq=this.normSq(),ang=.5*z.im*Math.log(normSq)+z.re*subAng,norm=Math.exp(-z.im*subAng)*Math.pow(normSq,.5*z.re);return complex(norm*Math.cos(ang),norm*Math.sin(ang))}static norm(z){return z.norm()}static normSq(z){return z.normSq()}static inv(z){return z.conj().scale(1/z.normSq())}static scale(z,k){return z.scale(k)}static add(z1,z2){return z1.add(z2)}static sub(z1,z2){return z1.sub(z2)}static mult(z1,z2){return z1.mult(z2)}static div(z1,z2){return z1.div(z2)}static pow(z1,z2){return z1.pow(z2)}static exp(z){return z.exp()}static ln(z){return z.ln()}static sqrt(z){return z.sqrt()}static sin(z){return z.sin()}static cos(z){return z.cos()}static tan(z){return z.tan()}static sinh(z){return z.sinh()}static cosh(z){return z.cosh()}static tanh(z){return z.tanh()}static infinite(z){const norm=z.norm();return z.re===1/0||z.re===-1/0||z.im===1/0||z.im===-1/0||norm===1/0}static nan(z){return isNaN(z.re)||isNaN(z.im)}static gamma(z){if(z.re<.5)return Complex.div(complex(Math.PI,0),Complex.mult(z.scale(Math.PI).sin(),Complex.gamma(complex(1-z.re,-z.im))));{z=Complex.sub(z,complex(1,0));let x=complex(pValues[0],0);for(let i=1;i<pValues.length;i++)x=Complex.add(x,Complex.div(complex(pValues[i],0),Complex.add(z,complex(i,0))));const t=Complex.add(z,complex(7.5,0));return Complex.pow(t,z.add(complex(.5,0))).mult(t.scale(-1).exp()).mult(x).scale(Math.sqrt(2*Math.PI))}}static beta(z1,z2){return Complex.div(Complex.mult(Complex.gamma(z1),Complex.gamma(z2)),Complex.gamma(z1.add(z2)))}static max(z1,z2){return z1.normSq()<z2.normSq()?z2:z1}static min(z1,z2){return z1.normSq()>z2.normSq()?z2:z1}iadd(z){this.re+=z.re,this.im+=z.im}isub(z){this.re-=z.re,this.im-=z.im}}function complex(real,imaginary){return new Complex(real,imaginary)}class Vector{constructor(values){this.values=values,this.dimension=values.length}get(index){return this.values[index]}scale(z){const result=[];for(let i=0;i<this.dimension;i++)result.push(Complex.mult(this.get(i),z));return vector(result)}realScale(k){const result=[];for(let i=0;i<this.dimension;i++)result.push(this.get(i).scale(k));return vector(result)}add(Z){const result=[];for(let i=0;i<this.dimension;i++)result.push(Complex.add(this.get(i),Z.get(i)));return vector(result)}dot(Z){const result=complex(0,0);for(let i=0;i<this.dimension;i++)result.iadd(Complex.mult(this.get(i),Z.get(i).conj()));return result}norm(){return Math.sqrt(this.dot(this).re)}angleTo(Z){return Math.acos(this.dot(Z).re/(this.norm()*Z.norm()))}static lerp(Z1,Z2,t){return Z1.realScale(1-t).add(Z2.scale(t))}}function vector(...values){return values[0]instanceof Complex?new Vector(values):new Vector(values[0])}module.exports={Complex:Complex,complex:complex,integrateOverComplexVariable:function(f,z0,z1,samples=100){const step=Complex.sub(z1,z0).scale(1/samples),stepNorm=step.norm();let z=Complex.add(z0,step.scale(.5)),result=complex(0,0);for(let i=0;i<samples;i++)result.iadd(f(z).scale(stepNorm)),z.iadd(step);return result},integrateOverParameter:function(f,a=0,b=1,samples=100){const step=(b-a)/samples;let t=a+step/2,result=complex(0,0);for(let i=0;i<samples;i++)result.iadd(f(t).scale(step)),t+=step;return result},Vector:Vector,vector:vector}},{}],3:[function(require,module,exports){const{Euclid:Euclid}=require("./geometry.js"),{complex:complex,Complex:Complex,integrateOverParameter:integrateOverParameter}=require("./complex.js");function fourierCoefficients(f,N){const coefs=[];for(let n=-N;n<=N;n++){const F=t=>Complex.mult(f(t),Complex.exp(complex(0,-2*Math.PI*n*t)));coefs.push(integrateOverParameter(F,0,1))}return coefs}module.exports={parameterizePoints:function(points){const N=points.length,segmentLength=1/(N-1);return t=>{if(1===t)return points[N-1];{const index=Math.floor(t/segmentLength);return Euclid.lerp(points[index],points[index+1],t/segmentLength-Math.floor(t/segmentLength))}}},fourierCoefficients:fourierCoefficients,fourierSeries:function(f,N){const coefs=fourierCoefficients(f,N);return t=>{const result=complex(0,0);for(let n=-N;n<=N;n++){const coef=coefs[n+N];result.iadd(Complex.mult(coef,Complex.exp(complex(0,2*Math.PI*n*t))))}return result}}}},{"./complex.js":2,"./geometry.js":4}],4:[function(require,module,exports){const{Complex:Complex,complex:complex}=require("./complex.js");class Euclid{static lineIntersection(p1,v1,p2,v2){const x1=p1.re,y1=p1.im,x2=p1.re+v1.re,y2=p1.im+v1.im,x3=p2.re,y3=p2.im,x4=p2.re+v2.re,y4=p2.im+v2.im,denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);if(0==denom)return null;const t=((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denom;return p1.add(v1.scale(t))}static midpoint(p1,p2){return p1.add(p2).scale(.5)}static lerp(p1,p2,t){return Complex.add(p1.scale(1-t),p2.scale(t))}static circleCenter(p1,p2,p3){return Euclid.lineIntersection(Euclid.midpoint(p1,p2),p2.sub(p1).perp(),Euclid.midpoint(p2,p3),p3.sub(p2).perp())}static centroid(P){let xTotal=0,yTotal=0;for(let point of P)xTotal+=point.re,yTotal+=point.im;return complex(xTotal/P.length,yTotal/P.length)}static distance(p1,p2){return p2.sub(p1).norm()}static project(p1,p2){return p2.scale(p1.dot(p2)/p2.normSq())}}class Poincare{static translatePToOrigin(z,P){return z.sub(P).div(complex(1,0).sub(P.conj().mult(z)))}static translateOriginToP(z,P){return z.add(P).div(complex(1,0).add(P.conj().mult(z)))}static segment(t,A,B){return Poincare.translateOriginToP(Poincare.translatePToOrigin(B,A).scale(t),A)}static line(t,A,B){return Poincare.translateOriginToP(Poincare.translatePToOrigin(B,A).unit().scale(2*t-1),A)}static regPolyDist(p,q){if((p-2)*(q-2)<=4)return void console.error(`Error: cannot compute regular polygon distance for p=${p}, q=${q}`);const tan1=Math.tan(Math.PI/2-Math.PI/q),tan2=Math.tan(Math.PI/p);return Math.sqrt((tan1-tan2)/(tan1+tan2))}static polygon(N,verts){verts.length<2&&console.error("Error: can't draw polygon with less than 2 points");const result=[],nPerSide=Math.ceil(N/verts.length);(verts=verts.slice()).push(verts[0]);for(let i=0;i<verts.length-1;i++){const space=linspace(0,1,nPerSide);for(let value of space)result.push(Poincare.segment(value,verts[i],verts[i+1]))}return result}static rotate(z,P,angle){return Poincare.translateOriginToP(Poincare.translatePToOrigin(z,P,!0).rotate(angle),P,!0)}static rotateMultiple(Z,P,angle){const result=[];for(let vert of Z)result.push(this.rotate(vert,P,angle));return result}static unitCircleInvert(z){return z.conj().inv()}static circleInvert(z,r,P){return P.add(complex(r*r,0).div(z.sub(P).conj()))}static reflect(z,p1,p2){const center=Euclid.circleCenter(p1,p2,Poincare.unitCircleInvert(p1));return null==center||center.norm()>1e3||isNaN(center.re)||isNaN(center.im)?p1.add(Euclid.project(z.sub(p1),p2.sub(p1))).scale(2).sub(z):Poincare.circleInvert(z,Euclid.distance(p1,center),center)}static reflectMultiple(Z,p1,p2){const result=[];for(let vert of Z)result.push(this.reflect(vert,p1,p2));return result}static inverseCayley(z){const one=complex(1,0);return one.add(z).div(one.sub(z)).mult(complex(0,1))}static toKleinDisk(z){const denom=.5*(1+z.normSq());return complex(z.re/denom,z.im/denom)}static hypDistance(z1,z2){const euclideanDistanceToOrigin=z1.sub(z2).norm();return Math.log((1+euclideanDistanceToOrigin)/(1-euclideanDistanceToOrigin))}}module.exports={Euclid:Euclid,Poincare:Poincare}},{"./complex.js":2}],5:[function(require,module,exports){function snormal(X){const norm=Math.sqrt(X[0]*X[0]+X[1]*X[1]+X[2]*X[2]);return[X[0]/norm,X[1]/norm,X[2]/norm]}function ssub(s,X,Y){return[X[0]+s*Y[0],X[1]+s*Y[1],X[2]+s*Y[2]]}module.exports={snormal:snormal,ssub:ssub,sscale:function(s,X){return[s*X[0],s*X[1],s*X[2]]},icosphere:function(subdivisions=0){const scale=1/(2*Math.sin(2*Math.PI/5)),phi=scale*(1+Math.sqrt(5))/2,vertices=[[-scale,phi,0],[scale,phi,0],[-scale,-phi,0],[scale,-phi,0],[0,-scale,phi],[0,scale,phi],[0,-scale,-phi],[0,scale,-phi],[phi,0,-scale],[phi,0,scale],[-phi,0,-scale],[-phi,0,scale]],triangleIndices=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[11,10,2],[5,11,4],[1,5,9],[7,1,8],[10,7,6],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[9,8,1],[4,9,5],[2,4,11],[6,2,10],[8,6,7]];let triangles=[];for(let index of triangleIndices)triangles.push([vertices[index[0]],vertices[index[1]],vertices[index[2]]]);const baryCoefs=[[0,0],[.5,0],[1,0],[0,.5],[.5,.5],[0,1]],trindices=[[0,1,3],[1,2,4],[1,3,4],[3,4,5]];for(let i=0;i<subdivisions;i++){const newTriangles=[];for(let tri of triangles){let newVertices=[];const u=[tri[1][0]-tri[0][0],tri[1][1]-tri[0][1],tri[1][2]-tri[0][2]],v=[tri[2][0]-tri[0][0],tri[2][1]-tri[0][1],tri[2][2]-tri[0][2]];for(let coef of baryCoefs)newVertices.push(ssub(coef[1],ssub(coef[0],tri[0],u),v));for(let trindex of trindices)newTriangles.push([newVertices[trindex[0]],newVertices[trindex[1]],newVertices[trindex[2]]])}triangles=newTriangles.slice()}for(let i=0;i<triangles.length;i++)triangles[i][0]=snormal(triangles[i][0]),triangles[i][1]=snormal(triangles[i][1]),triangles[i][2]=snormal(triangles[i][2]);return triangles}}},{}],6:[function(require,module,exports){const config_EPSILON=1e-8;class Matrix{constructor(arr){if("number"==typeof arr[0]&&(arr=[arr]),this.mat=arr,this.cols=this.mat[0].length,this.rows=this.mat.length,0===this.rows||0===this.cols)throw new Error(`Invalid matrix dimensions ${this.rows} x ${this.cols}.`);this.isSquare=this.rows===this.cols}static randomMatrix(m,n){let arr=[];for(let i=0;i<m;i++){arr[i]=[];for(let j=0;j<n;j++)arr[i][j]=Math.random()}return new Matrix(arr)}static randomIntegerMatrix(m,n,lower=0,upper=100){lower=Math.floor(lower);let arr=[],range=(upper=Math.floor(upper+1))-lower;for(let i=0;i<m;i++){arr[i]=[];for(let j=0;j<n;j++)arr[i][j]=lower+Math.floor(Math.random()*range)}return new Matrix(arr)}static emptyMatrix(m,n){return Matrix.fillMatrix(m,n,0)}static fillMatrix(m,n,v){const arr=[];for(let i=0;i<m;i++){arr[i]=[];for(let j=0;j<n;j++)arr[i][j]=v}return new Matrix(arr)}static identity(n){const arr=[];for(let i=0;i<n;i++){arr[i]=[];for(let j=0;j<n;j++)arr[i][j]=i===j?1:0}return new Matrix(arr)}static determinant2x2(a,b,c,d){return a*d-b*c}static rotationMatrix2D(angle){return new Matrix([[Math.cos(angle),-Math.sin(angle)],[Math.sin(angle),Math.cos(angle)]])}static rotationMatrix3D(angleX,angleY,angleZ){const sinX=Math.sin(angleX),cosX=Math.cos(angleX),sinY=Math.sin(angleY),cosY=Math.cos(angleY),sinZ=Math.sin(angleZ),cosZ=Math.cos(angleZ),rotX=new Matrix([[1,0,0],[0,cosX,-sinX],[0,sinX,cosX]]),rotY=new Matrix([[cosY,0,sinY],[0,1,0],[-sinY,0,cosY]]),rotZ=new Matrix([[cosZ,-sinZ,0],[sinZ,cosZ,0],[0,0,1]]);return Matrix.multiply(Matrix.multiply(rotX,rotY),rotZ)}static multiply(mat1,mat2){if(mat1.cols!==mat2.rows)throw new Error("Incompatible matrix dimensions. must be m x r and r x n");const res=[];for(let i=0;i<mat1.rows;i++){const row=[];for(let j=0;j<mat1.cols;j++){let dot=0;for(let k=0;k<mat2.rows;k++)dot+=mat1.mat[i][k]*mat2.mat[k][j];row.push(dot)}res.push(row)}return new Matrix(res)}static scale(mat,k){let newMat=mat.copy();return newMat.scale(k),newMat}static add(mat1,mat2){let newMat=mat1.copy();return newMat.add(mat2),newMat}static sub(mat1,mat2){let newMat=mat1.copy();return newMat.sub(mat2),newMat}static detCofactorExpansion(mat){if(mat.isSquare){if(mat.rows>10)throw new Error("For larger matrices, use Matrix.det (cofactor expansion is inefficient and computation time grows with the factorial of matrix dimension).");if(2===mat.rows&&2===mat.cols)return Matrix.determinant2x2(mat.mat[0][0],mat.mat[0][1],mat.mat[1][0],mat.mat[1][1]);{let sign=1,bottom=mat.withoutRow(0),res=0;for(let j=0;j<mat.rows;j++)res+=sign*mat.mat[0][j]*Matrix.detCofactorExpansion(bottom.withoutColumn(j)),sign=-sign;return res}}throw new Error("The determinant is only defined for square matrices.")}static det(mat){let prod=null;if(mat.isSquare){let newMat=Matrix.LUDecomposition(mat).U;for(let d=0;d<newMat.rows&&(null===prod?prod=newMat.mat[d][d]:prod*=newMat.mat[d][d],0!==prod);d++);return prod}throw new Error("The determinant is only defined for square matrices.")}static ref(mat){let newMat=mat.copy();return newMat.ref(),newMat}static rref(mat){let newMat=mat.copy();return newMat.rref(),Matrix.cheapMatrixRound(newMat)}static columnNorm(mat,j){let squaredTotal=0;for(let i=0;i<mat.rows;i++)squaredTotal+=mat.get(i,j)*mat.get(i,j);return Math.sqrt(squaredTotal)}static householderReflection(mat){if(1!==mat.cols)throw new Error("Can only compute Householder matrix for column vectors");const alpha=mat.get(0,0);let scale=1===mat.rows?0:Matrix.columnNorm(mat.submatrix(1,mat.rows,0,1),0);scale*=scale;let tau,v=mat.copy();if(0===scale)tau=0;else{const t=Math.sqrt(alpha*alpha+scale);v.mat[0][0]=alpha<=0?alpha-t:-scale/(alpha+t),tau=2*v.get(0,0)*v.get(0,0)/(scale+v.get(0,0)*v.get(0,0)),v=Matrix.scale(v,1/v.get(0,0))}return Matrix.sub(Matrix.identity(mat.rows),Matrix.scale(Matrix.multiply(v,Matrix.transpose(v)),tau))}static QRDecomposition(mat){let R=mat.copy(),Q=Matrix.identity(mat.rows);for(let j=0;j<mat.cols;j++){const reflect=Matrix.householderReflection(R.submatrix(j,mat.rows,j,j+1)),H=Matrix.identity(mat.rows);for(let a=j;a<mat.rows;a++)for(let b=j;b<mat.rows;b++)H.mat[a][b]=reflect.get(a-j,b-j);R=Matrix.multiply(H,R),Q=Matrix.multiply(H,Q)}return{Q:Matrix.transpose(Q.submatrix(0,mat.cols,0,mat.cols)),R:R.submatrix(0,mat.cols,0,mat.cols)}}static eigenvalues(mat){if(!mat.isSquare)throw new Error("can't compute eigenvalues of non-square matrix");let A=mat.copy();for(let i=0;i<10;i++){const decomposition=Matrix.QRDecomposition(A);A=Matrix.multiply(decomposition.R,decomposition.Q)}const result=[];for(let i=0;i<mat.rows;i++)result.push(A.get(i,i));return result}static eigenpairs(mat){}static exp(mat){}static log(mat){}static pow(mat){}static LUDecomposition(mat){if(mat.isSquare){let L,U;L=Matrix.emptyMatrix(mat.rows,mat.cols),U=Matrix.emptyMatrix(mat.rows,mat.cols);for(let i=0;i<mat.rows;i++){for(let k=i;k<mat.rows;k++){let sum=0;for(let j=0;j<i;j++)sum+=L.mat[i][j]*U.mat[j][k];U.mat[i][k]=mat.mat[i][k]-sum}for(let k=i;k<mat.rows;k++)if(i===k)L.mat[i][i]=1;else{let sum=0;for(let j=0;j<i;j++)sum+=L.mat[k][j]*U.mat[j][i];L.mat[k][i]=(mat.mat[k][i]-sum)/U.mat[i][i]}}return{L:L,U:U}}throw new Error("The LU-decomposition can only be found for a square matrix.")}static minors(mat){return mat.minors()}static cofactors(mat){return mat.cofactors()}static adjugate(mat){return mat.adjugate()}static inverse(mat){return mat.inverse()}static transpose(mat){return mat.transpose()}static toLatex(mat){return mat.toLatex()}static cheapMatrixRound(mat){let newMat=mat.copy();return newMat.applyIndexFunction(((v,i,j)=>(x=>{let u=Math.ceil(x),l=Math.floor(x);return Math.abs(x-u)<config_EPSILON?u:Math.abs(x-l)<config_EPSILON?l:x})(v))),newMat}copy(){const newMatrix=Matrix.emptyMatrix(this.rows,this.cols);for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)newMatrix.mat[i][j]=this.mat[i][j];return newMatrix}scale(k){for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)this.mat[i][j]*=k}add(mat){if(this.rows!==mat.rows||this.cols!=mat.cols)throw new Error("Invalid matrix dimensions (both matrices should be the same size).");for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)this.mat[i][j]+=mat.mat[i][j]}sub(mat){let matCopy=mat.copy();matCopy.scale(-1),this.add(matCopy)}applyIndexFunction(f){for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)this.mat[i][j]=f(this.mat[i][j],i,j)}minors(){let res=Matrix.emptyMatrix(this.rows,this.cols);for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)res.mat[i][j]=this.withoutRow(i).withoutColumn(j).determinant();return Matrix.cheapMatrixRound(res)}cofactors(){let minors=this.minors();return minors.applyIndexFunction(((v,i,j)=>(i+j)%2==0?v:-v)),minors}adjugate(){return this.cofactors().transpose()}inverse(){let det=this.determinant();if(0===det)throw new Error("Matrix is singular.");return Matrix.cheapMatrixRound(Matrix.scale(this.adjugate(),1/det))}transpose(){let mat=Matrix.emptyMatrix(this.cols,this.rows);for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)mat.mat[j][i]=this.mat[i][j];return mat}getColumn(i){let col=[];for(let j=0;j<this.mat.length;j++)col.push(this.mat[j][i]);return col}getRow(i){return this.mat[i]}get(i,j){return this.mat[i][j]}rowSwap(i1,i2){if(i1<this.rows&&i2<this.rows){let temp;return temp=this.mat[i1].slice(),this.mat[i1]=this.mat[i2].slice(),void(this.mat[i2]=temp)}throw new Error("Row is invalid.")}columnSwap(j1,j2){if(j1<this.cols&&j2<this.cols){let mat=this.transpose();return mat.rowSwap(j1,j2),void(this.mat=mat.transpose().mat)}throw new Error("Column is invalid.")}submatrix(i1,i2,j1,j2){if(!(0<=i1&&i1<=this.rows&&0<=j1&&j1<=this.cols))throw new Error("submatrix index out of range");if(i1>i2||j1>j2)throw new Error("invalid submatrix indices");const result=[];for(let i=i1;i<i2;i++){const row=[];for(let j=j1;j<j2;j++)row.push(this.mat[i][j]);result.push(row)}return new Matrix(result)}withoutRow(i){if(i>=this.rows)throw new Error("Row is invalid.");let mat=this.copy().mat;return mat.splice(i,1),new Matrix(mat)}withoutColumn(j){if(j>=this.cols)throw new Error("Column is invalid.");return this.transpose().withoutRow(j).transpose()}scaleRow(i,k){if(!(i<this.rows))throw new Error("Invalid row.");for(let j=0;j<this.cols;j++)this.mat[i][j]*=k}subtractScaledRow(row,rowToBeSubtracted,scale){rowToBeSubtracted=this.mat[rowToBeSubtracted];for(let j=0;j<this.cols;j++)this.mat[row][j]-=scale*rowToBeSubtracted[j]}rowHasLeadingOne(i){if(i<this.rows)for(let j=0;j<this.cols;j++){if(1===this.mat[i][j])return!0;if(0!==this.mat[i][j])return!1}throw new Error("Invalid row.")}columnOfFirstNonzero(i){if(i<this.rows){for(let j=0;j<this.cols;j++)if(0!==this.mat[i][j])return j;return-1}throw new Error("Invalid row.")}ref(){}rref(){let i,lead=0;for(let r=0;r<this.rows&&!(this.cols<=lead);r++){for(i=r;0===this.mat[i][lead]&&(i++,this.rows!==i||(i=r,lead++,this.cols!==lead)););for(this.rowSwap(i,r),0!==this.mat[r][lead]&&this.scaleRow(r,1/this.mat[r][lead]),i=0;i<this.rows;i++)i!==r&&this.subtractScaledRow(i,r,this.mat[i][lead]);lead++}}determinant(){return Matrix.det(this)}trace(){if(this.isSquare){let total=0;for(let i=0;i<this.rows;i++)total+=this.mat[i][i];return total}throw new Error("Trace is only defined for square matrices.")}rowSum(i){return this.getRow(i).reduce(((x,y)=>x+y),0)}columnSum(j){return this.getColumn(j).reduce(((x,y)=>x+y),0)}rowAbsoluteSum(i){return this.getRow(i).reduce(((x,y)=>Math.abs(x)+Math.abs(y)),0)}columnAbsoluteSum(j){return this.getColumn(j).reduce(((x,y)=>Math.abs(x)+Math.abs(y)),0)}rowSums(){const totals=[];for(let i=0;i<this.rows;i++)totals.push(this.rowSum(i));return totals}columnSums(){const totals=[];for(let j=0;j<this.cols;j++)totals.push(this.columnSum(j));return totals}rowAbsoluteSums(){const totals=[];for(let i=0;i<this.rows;i++)totals.push(this.rowAbsoluteSum(i));return totals}columnAbsoluteSums(){const totals=[];for(let j=0;j<this.cols;j++)totals.push(this.columnAbsoluteSum(j));return totals}norm(){return Math.max(...this.columnAbsoluteSums())}toString(){let seg,str="";for(let i=0;i<this.rows;i++){str+="|  ";for(let j=0;j<this.cols;j++)seg=""+Math.floor(100*this.mat[i][j])/100,seg+=" ".repeat(5-seg.length),str+=seg,j<this.cols-1&&(str+="   ");str+="  |\n"}return str=" _"+" ".repeat(3*(this.cols-1)+5*this.cols+2)+"_\n"+str,str+=" -"+" ".repeat(3*(this.cols-1)+5*this.cols+2)+"- ",str}toLatex(openDelim="$$",closeDelim="$$"){let str=openDelim+"\\begin{pmatrix}";for(let i=0;i<this.rows;i++){for(let j=0;j<this.cols;j++)j+1<this.cols?str+=this.mat[i][j]+"&":str+=""+this.mat[i][j];i!==this.rows-1&&(str+="\\\\")}return str+="\\end{pmatrix}"+closeDelim,str}show(){let str=this.toString();console.log(str)}}module.exports={Matrix:Matrix,matrix:function(arr){return new Matrix(arr)}}},{}],7:[function(require,module,exports){const{matrix:matrix}=require("./matrix.js"),{complex:complex}=require("./complex.js");module.exports={stereographic:function(z){return complex(z[0]/(1-z[2]),z[1]/(1-z[2]))},inverseStereoProject:function(z){const normSq=z.normSq();return matrix([2*z.re/(1+normSq),2*z.im/(1+normSq),(normSq-1)/(1+normSq)]).transpose()},perspectiveProject:function(Z,orbit,fov){const values=Z.getColumn(0),x=values[0],y=values[1],z=values[2],denom=orbit+fov*y;return complex(x/denom,z/denom)}}},{"./complex.js":2,"./matrix.js":6}],8:[function(require,module,exports){class rVector{constructor(x,y){this.x=x,this.y=y}dot(v){return this.x*v.x+this.y*v.y}magSq(){return this.x*this.x+this.y*this.y}mag(){return Math.sqrt(this.magSq())}scale(k){return new rVector(this.x*k,this.y*k)}proj(v){return v.scale(this.dot(v)/v.magSq())}unit(){return this.scale(1/this.mag())}angleBetween(v){return Math.acos(this.dot(v).scale(this.mag()*v.mag()))}perp(){return new rVector(-this.y,this.x)}reflect(pointOnMirror,mirrorNormal){return pointOnMirror.add(this.sub(pointOnMirror).proj(mirrorNormal)).scale(2).sub(this)}add(v){return new rVector(this.x+v.x,this.y+v.y)}sub(v){return new rVector(this.x-v.x,this.y-v.y)}}module.exports={rVector:rVector,rvec:function(x,y){return new rVector(x,y)}}},{}],9:[function(require,module,exports){const tracker=new class{constructor(errorDivID,successMsg,callback=null,successCallback=null){this.hasError=!1,this.message=null,this.successMsg=successMsg,this.target=errorDivID,this.callback=callback,this.successCallback=successCallback}setTarget(errorDivID){this.target=errorDivID}setCallback(callback){this.callback=callback}setSuccessCallback(successCallback){this.successCallback=successCallback}defaultCallback(target){target&&(target.innerText=this.message,target.style.color="red",target.style.display="block")}defaultSuccessCallback(target){target&&(target.innerText=this.message,target.style.color="green",target.style.display="block")}error(message){this.hasError=!0,this.message=message;const target=document.querySelector(`#${this.target}`);null===this.callback?this.defaultCallback(target):this.callback(this.message,target)}clear(){this.hasError=!1,this.message=this.successMsg;const target=document.querySelector(`#${this.target}`);null===this.successCallback?this.defaultCallback(target):this.successCallback(this.message,target)}}(null,"Parsing successful!");module.exports={tracker:tracker}},{}],10:[function(require,module,exports){function clearFractions(text,depth=0){if(depth>9)return console.error("fractions nested too deeply"),"";let letter,buffer,bCount,j,newString="",fracOpen=!1;for(let i=0;i<text.length;i++)if(letter=text[i],i>=4&&"frac"===text.slice(i-4,i)&&(fracOpen=!0),"{"===letter&&fracOpen){for(buffer="",bCount=1,j=i+1;j<text.length;j++){if("{"===text[j])bCount++;else if("}"===text[j]&&(bCount--,0===bCount))break;buffer+=text[j]}i>=4&&"frac"===text.slice(i-4,i)?newString+="(("+clearFractions(buffer,depth+1)+")/":(newString+="("+clearFractions(buffer,depth+1)+"))",fracOpen=!1),i=j}else newString+=letter;return newString.replace(/\\frac/g,"")}module.exports={cleanLatex:function(text){return text=(text=(text=(text=clearFractions(text=(text=text.replace(/\s/g,"")).replace(/\\cdot/g,"*").replace(/\\operatorname{(.*?)}/g,((tot,group1)=>group1)))).replace(/(\\left)|(\\right)/g,"")).replace(/\\/g,"")).replace(/{/g,"(").replace(/}/g,")")}}},{}],11:[function(require,module,exports){const{Parser:Parser}=require("./parser.js"),{InfixParselet:InfixParselet,PrefixParselet:PrefixParselet,AssignParselet:AssignParselet,BinaryOperatorParselet:BinaryOperatorParselet,CallParselet:CallParselet,GroupParselet:GroupParselet,NameParselet:NameParselet,NumberParselet:NumberParselet,PrefixOperatorParselet:PrefixOperatorParselet}=require("./parselets.js"),{TokenType:TokenType}=require("./tokentype.js"),{Precedence:Precedence}=require("./precedence.js");module.exports={ExpressionParser:class extends Parser{constructor(tokens){super(tokens),this.registerPrefix(TokenType.NUMBER,new NumberParselet),this.registerPrefix(TokenType.NAME,new NameParselet),this.registerInfix(TokenType.ASSIGN,new AssignParselet),this.registerPrefix(TokenType.LEFT_PAREN,new GroupParselet),this.registerInfix(TokenType.LEFT_PAREN,new CallParselet),this.prefix(TokenType.PLUS,Precedence.PREFIX),this.prefix(TokenType.MINUS,Precedence.PREFIX),this.infixLeft(TokenType.COLON,Precedence.CALL),this.infixLeft(TokenType.PLUS,Precedence.SUM),this.infixLeft(TokenType.MINUS,Precedence.SUM),this.infixLeft(TokenType.ASTERISK,Precedence.PRODUCT),this.infixLeft(TokenType.SLASH,Precedence.PRODUCT),this.infixRight(TokenType.CARET,Precedence.EXPONENT)}prefix(tokenType,precedence){this.registerPrefix(tokenType,new PrefixOperatorParselet(precedence))}infixLeft(tokenType,precedence){this.registerInfix(tokenType,new BinaryOperatorParselet(precedence,!1))}infixRight(tokenType,precedence){this.registerInfix(tokenType,new BinaryOperatorParselet(precedence,!0))}}}},{"./parselets.js":14,"./parser.js":15,"./precedence.js":16,"./tokentype.js":18}],12:[function(require,module,exports){const{TokenType:TokenType}=require("./tokentype.js");class Expression{}module.exports={Expression:Expression,AssignExpression:class extends Expression{constructor(left,right){super(),this.mLeft=left,this.mRight=right}toString(){return`(${this.mLeft.toString()} = ${this.mRight.toString()})`}},CallExpression:class extends Expression{constructor(func,args){super(),this.mFunction=func,this.mArgs=args}toString(){const args=this.mArgs.join();return`${this.mFunction.toString()}(${args})`}},NameExpression:class extends Expression{constructor(name){super(),this.mName=name}toString(){return this.mName}},NumberExpression:class extends Expression{constructor(number){super(),this.mNumber=number}toString(){return this.mNumber.toString()}},OperatorExpression:class extends Expression{constructor(left,operator,right){super(),this.mLeft=left,this.mOperator=operator,this.mRight=right}toString(){return`(${this.mLeft.toString()} ${TokenType.toStr(this.mOperator)} ${this.mRight.toString()})`}},PrefixExpression:class extends Expression{constructor(operator,right){super(),this.mOperator=operator,this.mRight=right}toString(){return`(${TokenType.toStr(this.mOperator)}${this.mRight})`}}}},{"./tokentype.js":18}],13:[function(require,module,exports){const{TokenType:TokenType}=require("./tokentype.js"),{Token:Token}=require("./token.js"),{Trie:Trie}=require("../trie.js"),{tracker:tracker}=require("../errors.js"),num="0123456789",alnum="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";module.exports={Lexer:class{constructor(mText,allowUnboundIdentifiers=!1){this.mPunctuators=[],this.mText=mText,this.index=0,this.allowUnboundIdentifiers=allowUnboundIdentifiers,this.setScope({})}setScope(scope){this.scope=scope,this.builtinLookup=new Trie(Object.keys(void 0===scope.builtin?{}:scope.builtin)),this.userGlobalLookup=new Trie(Object.keys(void 0===scope.userGlobal?{}:scope.userGlobal))}setAllowUnboundIdentifiers(allowUnboundIdentifiers){this.allowUnboundIdentifiers=allowUnboundIdentifiers}setText(mText){this.mPunctuators=[],this.mText=mText,this.index=0}getTokenName(tokenizingAssignment=!1,assignmentEncountered=!1){let buffer="";for(;this.index<this.mText.length&&alnum.includes(this.mText[this.index]);)buffer+=this.mText[this.index],this.index++;const identifiers=[];for(;buffer.length>0;){let possibleIdentifier,i,matchFound=!1;for(i=buffer.length-1;i>=0;i--)if(possibleIdentifier=buffer.slice(0,i+1),this.builtinLookup.containsKey(possibleIdentifier)||this.userGlobalLookup.containsKey(possibleIdentifier)){matchFound=!0;break}if(matchFound)identifiers.push(possibleIdentifier),buffer=buffer.slice(i+1,buffer.length);else{if(!alnum.includes(possibleIdentifier[0])||num.includes(possibleIdentifier[0]))return tracker.error("unexpected number following identifier"),void this.kill();if(!this.allowUnboundIdentifiers&&!tokenizingAssignment)return tracker.error(`Undefined identifier ${buffer}`),void this.kill();identifiers.push(buffer),buffer=""}}for(let identifier of identifiers)this.mPunctuators.push(new Token(TokenType.NAME,identifier)),this.mPunctuators.push(new Token(TokenType.ASTERISK,"*"));this.mPunctuators.pop()}getTokenNumber(){let number="",decimalEncounted=!1;for(;this.index<this.mText.length&&(num.includes(this.mText[this.index])||"."===this.mText[this.index]);){if("."===this.mText[this.index]){if(decimalEncounted)return tracker.error("two decimal points encountered in number"),void this.kill();decimalEncounted=!0}number+=this.mText[this.index],this.index++}this.mPunctuators.push(new Token(TokenType.NUMBER,number))}kill(){this.index=this.mText.length}tokenize(){this.mPunctuators=[],this.index=0;const tokenizingAssignment=this.mText.includes("=");let assignmentEncountered=!1;for(;this.index<this.mText.length;){const char=this.mText[this.index];if("("===char)this.mPunctuators.push(new Token(TokenType.LEFT_PAREN,char));else if(")"===char)this.mPunctuators.push(new Token(TokenType.RIGHT_PAREN,char));else if(","===char)this.mPunctuators.push(new Token(TokenType.COMMA,char));else if("="===char)this.mPunctuators.push(new Token(TokenType.ASSIGN,char)),assignmentEncountered=!0;else if("+"===char)this.mPunctuators.push(new Token(TokenType.PLUS,char));else if("-"===char)this.mPunctuators.push(new Token(TokenType.MINUS,char));else if("*"===char)this.mPunctuators.push(new Token(TokenType.ASTERISK,char));else if("/"===char)this.mPunctuators.push(new Token(TokenType.SLASH,char));else if("^"===char)this.mPunctuators.push(new Token(TokenType.CARET,char));else{if(":"!==char){if(num.includes(char)||"."===char){this.getTokenNumber();continue}if(alnum.includes(char)){this.getTokenName(tokenizingAssignment,assignmentEncountered);continue}return tracker.error(`bruh what is this character even doing in your input ${char}`),void this.kill()}this.mPunctuators.push(new Token(TokenType.COLON,char))}this.index++}this.mPunctuators.push(new Token(TokenType.EOF,null));const tokens=this.mPunctuators.length>0?[this.mPunctuators[0]]:[];for(let i=0;i<this.mPunctuators.length-1;i++){const token=this.mPunctuators[i],nextToken=this.mPunctuators[i+1];let needsMultiplication=!1;if(token.mtype===TokenType.NAME&&nextToken.mtype===TokenType.NUMBER)return tracker.error("unexpected number following identifier"),void this.kill();token.mtype===TokenType.NUMBER&&nextToken.mtype===TokenType.NAME||token.mtype===TokenType.NUMBER&&nextToken.mtype===TokenType.LEFT_PAREN||token.mtype===TokenType.RIGHT_PAREN&&nextToken.mtype===TokenType.NUMBER||token.mtype===TokenType.RIGHT_PAREN&&nextToken.mtype===TokenType.NAME||token.mtype===TokenType.RIGHT_PAREN&&nextToken.mtype===TokenType.LEFT_PAREN?needsMultiplication=!0:token.mtype===TokenType.NAME&&nextToken.mtype===TokenType.LEFT_PAREN&&(this.builtinLookup.containsKey(token.text)?needsMultiplication=!this.scope.builtin[token.text].isFunction:this.userGlobalLookup.containsKey(token.text)&&(needsMultiplication=!this.scope.userGlobal[token.text].isFunction)),needsMultiplication&&tokens.push(new Token(TokenType.ASTERISK,"*")),tokens.push(nextToken)}this.mPunctuators=tokens.slice(),this._validateTokens()}_checkIsFunction(token){return!(token.mtype!==TokenType.NAME||!this.scope.builtin[token.text]?.isFunction&&!this.scope.userGlobal[token.text]?.isFunction)}_validateTokens(){let equalCount=0;for(let i=0;i<this.mPunctuators.length-1;i++){const token=this.mPunctuators[i],nextToken=this.mPunctuators[i+1];if(this._checkIsFunction(token)&&nextToken.mtype!==TokenType.LEFT_PAREN)return void tracker.error(`Function call to ${token.text} requires parentheses`);token.mtype===TokenType.ASSIGN&&equalCount++}equalCount>1&&tracker.error("More than one equals sign present in expression")}getTokens(){return this.mPunctuators}}}},{"../errors.js":9,"../trie.js":19,"./token.js":17,"./tokentype.js":18}],14:[function(require,module,exports){const{Precedence:Precedence}=require("./precedence.js"),{TokenType:TokenType}=require("./tokentype.js"),{Expression:Expression,AssignExpression:AssignExpression,CallExpression:CallExpression,NameExpression:NameExpression,NumberExpression:NumberExpression,OperatorExpression:OperatorExpression,PrefixExpression:PrefixExpression}=require("./expressions.js"),{tracker:tracker}=require("../errors.js");class InfixParselet{parse(parser,left,token){}getPrecedence(){}}class PrefixParselet{parse(parser,token){}getPrecedence(){}}module.exports={InfixParselet:InfixParselet,PrefixParselet:PrefixParselet,AssignParselet:class extends InfixParselet{parse(parser,left,token){const right=parser.parseExpression(Precedence.ASSIGNMENT-1);if(left instanceof NameExpression||left instanceof CallExpression)return new AssignExpression(left,right);tracker.error("lhs of assignment should be identifier or function name with arguments")}getPrecedence(){return Precedence.ASSIGNMENT}},BinaryOperatorParselet:class extends InfixParselet{constructor(precedence,mIsRight){super(),this.mPrecedence=precedence,this.mIsRight=mIsRight}parse(parser,left,token){const right=parser.parseExpression(this.mPrecedence-(this.mIsRight?1:0));return new OperatorExpression(left,token.mtype,right)}getPrecedence(){return this.mPrecedence}},CallParselet:class extends InfixParselet{constructor(){super()}parse(parser,left,token){const args=[];if(!parser.peek(TokenType.RIGHT_PAREN))for(;!tracker.hasError;){if(args.push(parser.parseExpression()),parser.peek(TokenType.RIGHT_PAREN)){parser.consume(TokenType.RIGHT_PAREN);break}parser.consume(TokenType.COMMA)}return new CallExpression(left,args)}getPrecedence(){return Precedence.CALL}},GroupParselet:class extends PrefixParselet{parse(parser,token){const expr=parser.parseExpression();return parser.consume(TokenType.RIGHT_PAREN),expr}},NameParselet:class extends PrefixParselet{constructor(){super()}parse(parser,token){return new NameExpression(token.text)}},NumberParselet:class extends PrefixParselet{constructor(){super()}parse(parser,token){const value=parseFloat(token.text);if(!isNaN(value))return new NumberExpression(parseFloat(token.text));tracker.error(`Invalid number literal ${value}`)}},PrefixOperatorParselet:class extends PrefixParselet{constructor(precedence){super(),this.mPrecedence=precedence}parse(parser,token){const right=parser.parseExpression(this.mPrecedence);return new PrefixExpression(token.mtype,right)}}}},{"../errors.js":9,"./expressions.js":12,"./precedence.js":16,"./tokentype.js":18}],15:[function(require,module,exports){const{tracker:tracker}=require("../errors.js"),{TokenType:TokenType}=require("./tokentype.js"),{Precedence:Precedence}=require("./precedence.js"),{Token:Token}=require("./token.js");module.exports={Parser:class{constructor(tokens){this.mTokens=tokens,this.mPrefixParselets={},this.mInfixParselets={},this.index=0}registerPrefix(tokenType,parselet){this.mPrefixParselets[tokenType]=parselet}registerInfix(tokenType,parselet){this.mInfixParselets[tokenType]=parselet}parseExpression(precedence=Precedence.LOWEST){let token=this.consume();if(tracker.hasError)return;if(!Object.keys(this.mPrefixParselets).includes(token.mtype.toString()))return void(token.mtype===TokenType.EOF?tracker.error("Unexpected EOF while parsing (1)"):tracker.error("Invalid syntax"));let left=this.mPrefixParselets[token.mtype].parse(this,token);if(!tracker.hasError){for(;precedence<this.getPrecedence();)if(token=this.consume(),Object.keys(this.mInfixParselets).includes(token.mtype.toString())&&(left=this.mInfixParselets[token.mtype].parse(this,left,token),tracker.hasError))return;return left}}consume(expected=null){const token=this.lookAhead(0);if(null===expected||token.mtype!==TokenType.EOF){if(null===expected||token.mtype===expected)return this.index++,token;tracker.error("Unexpected EOF while parsing")}else tracker.error("Unexpected EOF while parsing")}lookAhead(distance){return this.index+distance<this.mTokens.length?this.mTokens[this.index+distance]:new Token(TokenType.EOF,null)}peek(expected){return this.lookAhead(0).mtype===expected}getPrecedence(){const currentToken=this.lookAhead(0);return Object.keys(this.mInfixParselets).includes(currentToken.mtype.toString())?this.mInfixParselets[currentToken.mtype].getPrecedence():Precedence.LOWEST}}}},{"../errors.js":9,"./precedence.js":16,"./token.js":17,"./tokentype.js":18}],16:[function(require,module,exports){module.exports={Precedence:class{static LOWEST=0;static ASSIGNMENT=1;static SUM=2;static PRODUCT=3;static EXPONENT=4;static PREFIX=5;static CALL=6}}},{}],17:[function(require,module,exports){module.exports={Token:class{constructor(tokenType,text){this.mtype=tokenType,this.text=text}toString(){return`<${this.mtype}, ${this.text}>`}}}},{}],18:[function(require,module,exports){module.exports={TokenType:class{static LEFT_PAREN=1;static RIGHT_PAREN=2;static COMMA=3;static ASSIGN=4;static PLUS=5;static MINUS=6;static ASTERISK=7;static SLASH=8;static CARET=9;static COLON=10;static NAME=11;static NUMBER=12;static EOF=13;constructor(value){this.value=value}static toStr(tokenType){return["(",")",",","=","+","-","*","/","^",":","","",""][tokenType-1]}}}},{}],19:[function(require,module,exports){class Node{static nodeID=0;constructor(value){this.value=value,this.id=Node.nodeID,Node.nodeID++,this.next=null,this.child=null}setNext(next){this.next=next}setChild(child){this.child=child}hasNext(){return null!==this.next}toString(){return`Node(${this.value})`}}class LinkedList{constructor(valuesArray=null){if(this.head=null,this.size=0,null!==valuesArray)for(let value of valuesArray)this.push(value)}push(value){const newNode=new Node(value);if(null===this.head)this.head=newNode;else{let node=this.head;for(;node.hasNext();)node=node.next;node.setNext(newNode)}return this.size++,newNode}remove(value){if(null===this.head)return!1;if(this.head.value===value)return this.head=this.head.next,this.size--,!0;{let node=this.head;for(;node.hasNext();){if(node.next.value===value)return node.next=node.next.next,this.size--,!0;node=node.next}return!1}}search(value){let node=this.head;for(;null!==node;){if(node.value===value)return node;node=node.next}return null}toString(){if(null===this.head)return"LinkedList([])";{let result="[",node=this.head;for(;null!==node;)result+=node.toString()+", ",node=node.next;return result=result.slice(0,-2)+"]",result}}}class Trie{static TERMINATOR="<end>";constructor(keysArray=null){if(this.root=null,this.maxDepth=0,this.size=0,null!==keysArray)for(let key of keysArray)this.insertKey(key)}insertKey(key){null===this.root&&(this.root=new LinkedList),this.maxDepth=Math.max(this.maxDepth,key.length);let list=this.root;for(let i=0;i<key.length;i++){const character=key[i],node=list.search(character);if(null===node){const newNode=list.push(character);newNode.setChild(new LinkedList),list=newNode.child}else list=node.child;i===key.length-1&&null===list.search(Trie.TERMINATOR)&&(list.push(Trie.TERMINATOR),this.size++)}}containsKey(key){if(null===this.root)return!1;let list=this.root;for(let character of key){const node=list.search(character);if(null===node)return!1;list=node.child}return null!==list.search(Trie.TERMINATOR)}containsPrefix(prefix){if(null===this.root)return!1;let list=this.root;for(let character of prefix){const node=list.search(character);if(null===node)return!1;list=node.child}return!0}remove(key){if(null===this.root)return!1;let list=this.root;for(let character of key){const node=list.search(character);if(null===node)return!1;list=node.child}const removalResult=list.remove(Trie.TERMINATOR);return removalResult&&this.size--,removalResult}prefixSearch(prefix,maxResults=100){if(null===this.root||""===prefix)return[];let node,list=this.root;for(let character of prefix){if(node=list.search(character),null===node)return[];list=node.child}const results=[];null!==list.search(Trie.TERMINATOR)&&results.push(prefix);const queue=[{node:list.head,suffix:""}];let current;for(;results.length<maxResults&&queue.length>0;){current=queue.pop();let currentNode=current.node,currentSuffix=current.suffix;for(;null!==currentNode;){if(currentNode.value===Trie.TERMINATOR){currentNode=currentNode.next;continue}if(null!==currentNode.child.search(Trie.TERMINATOR)&&results.push(prefix+currentSuffix+currentNode.value),queue.unshift({node:currentNode.child.head,suffix:currentSuffix+currentNode.value}),currentNode=currentNode.next,results.length===maxResults)break}}return results}}module.exports={Node:Node,LinkedList:LinkedList,Trie:Trie}},{}],20:[function(require,module,exports){const{complex:complex,Complex:Complex}=require("./math/complex.js"),defaultValueScope={z:complex(1,0),norm:z=>complex(z.norm(),0),normSq:z=>complex(z.normSq(),0),arg:z=>complex(z.arg(),0),inv:Complex.inv,exp:Complex.exp,ln:Complex.ln,sqrt:Complex.sqrt,sin:Complex.sin,cos:Complex.cos,tan:Complex.tan,sinh:Complex.sinh,cosh:Complex.cosh,tanh:Complex.tanh,re:z=>complex(z.re,0),im:z=>complex(z.im,0),Gamma:Complex.gamma,beta:Complex.beta,min:Complex.min,max:Complex.max,lerp:(z1,z2,t)=>Complex.mult(complex(1,0).sub(t),z1).add(z2.mult(t)),i:complex(0,1),pi:complex(Math.PI,0),tau:complex(2*Math.PI,0),e:complex(Math.E,0),realBounds:complex(0,0),imagBounds:complex(0,0)};module.exports={scope:{builtin:{z:{isFunction:!1},norm:{isFunction:!0},normSq:{isFunction:!0},arg:{isFunction:!0},inv:{isFunction:!0},exp:{isFunction:!0},ln:{isFunction:!0},sqrt:{isFunction:!0},sin:{isFunction:!0},cos:{isFunction:!0},tan:{isFunction:!0},sinh:{isFunction:!0},cosh:{isFunction:!0},tanh:{isFunction:!0},re:{isFunction:!0},im:{isFunction:!0},Gamma:{isFunction:!0},beta:{isFunction:!0},min:{isFunction:!0},max:{isFunction:!0},lerp:{isFunction:!0},i:{isFunction:!1},pi:{isFunction:!1},tau:{isFunction:!1},e:{isFunction:!1},realBounds:{isFunction:!1},imagBounds:{isFunction:!1},complex:{isFunction:!1,isType:!0},array:{isFunction:!1,isType:!0},matrix:{isFunction:!1,isType:!0},function:{isFunction:!1,isType:!0}},userGlobal:{}},defaultValueScope:defaultValueScope,valueScope:{}}},{"./math/complex.js":2}],21:[function(require,module,exports){const{cleanLatex:cleanLatex}=require("./parsing/latex_convert.js"),{tracker:tracker}=require("./parsing/errors.js"),{TokenType:TokenType}=require("./parsing/pratt/tokentype.js"),{Expression:Expression,AssignExpression:AssignExpression,CallExpression:CallExpression,NameExpression:NameExpression,NumberExpression:NumberExpression,OperatorExpression:OperatorExpression,PrefixExpression:PrefixExpression}=require("./parsing/pratt/expressions.js"),{Lexer:Lexer}=require("./parsing/pratt/lexer.js"),{ExpressionParser:ExpressionParser}=require("./parsing/pratt/expression_parser.js"),{Complex:Complex,complex:complex}=require("./math/complex.js"),{Matrix:Matrix,matrix:matrix}=require("./math/matrix.js"),{Euclid:Euclid,Poincare:Poincare}=require("./math/geometry.js"),{parameterizePoints:parameterizePoints,fourierCoefficients:fourierCoefficients,fourierSeries:fourierSeries}=require("./math/fourier.js"),{sscale:sscale,ssub:ssub,icosphere:icosphere}=require("./math/icosphere.js"),{stereographic:stereographic,inverseStereoProject:inverseStereoProject,perspectiveProject:perspectiveProject}=require("./math/projection.js"),{rvec:rvec}=require("./math/rvector.js"),{scope:scope,defaultValueScope:defaultValueScope,valueScope:valueScope}=require("./scope.js"),{evaluate:evaluate}=require("./evaluator.js");p5.disableFriendlyErrors=!0,window.plot=void 0,window.lastMouseX=void 0,window.lastMouseY=void 0;const MQ=MathQuill.getInterface(2),opsString=Object.keys(scope.builtin).filter((x=>x.length>1)).join(" "),fields={},menuHTML=(id,error=null)=>{let imageSrc,displayText;return null===error?(imageSrc="http://localhost:8000/data/settings_transparent.png",displayText="Settings"):(imageSrc="http://localhost:8000/data/error_transparent.png",displayText=error),`<div>${id}</div>\n    <div style="display:flex;">\n        <img src="${imageSrc}" style="width:25px;height:25px;" onclick="displayOverlayMenu(${id});" title="${displayText}"></img>\n    </div>`};function addField(parent=null){const newDiv=document.createElement("div");newDiv.setAttribute("class","math-input-div");const newSpan=document.createElement("span");newSpan.setAttribute("class","math-input");const newField=MQ.MathField(newSpan,{});newDiv.setAttribute("id",`math-input-div-${newField.id}`);const newMenu=document.createElement("div");if(newMenu.setAttribute("class","math-input-side-menu"),newMenu.setAttribute("id",`math-input-side-menu-${newField.id}`),newMenu.innerHTML=menuHTML(newField.id),newDiv.appendChild(newMenu),newDiv.appendChild(newSpan),null===parent){document.querySelector("#math-input-container").appendChild(newDiv),fields[newField.id]={id:newField.id,field:newField,last:null,next:null,container:newDiv}}else{document.querySelector(`#math-input-div-${parent.id}`).after(newDiv),fields[newField.id]={id:newField.id,field:newField,last:parent.field,next:parent.next,container:newDiv},fields[parent.field.id].next=newField,advance(parent.field.id,1)}return newField.id}function deleteField(id,preserve=!0){if(preserve&&1===Object.keys(fields).length)return;const entry=fields[id];null!==entry.next?null!==entry.last?(fields[entry.next.id].last=entry.last,fields[entry.last.id].next=entry.next):fields[entry.next.id].last=null:null!==entry.last&&(fields[entry.last.id].next=null),preserve&&advance(id,null===entry.last?1:-1),entry.container.parentNode.removeChild(entry.container),delete fields[id]}function advance(id,direction){const entry=fields[id];-1===direction&&null!==entry.last?(entry.last.focus(),entry.last.moveToRightEnd()):1===direction&&(null!==entry.next?(entry.next.focus(),entry.next.moveToRightEnd()):addField(entry))}function getCallbacks(id){const sideMenu=document.querySelector(`#math-input-side-menu-${id}`);return{callback:(message,target)=>{sideMenu.innerHTML=menuHTML(id,message)},successCallback:(message,target)=>{sideMenu.innerHTML=menuHTML(id)}}}document.addEventListener("mousedown",(event=>{const overlay=document.querySelector("#overlay-menu-container");overlay.contains(event.target)||(overlay.style.display="none")}));const firstField=addField();fields[firstField].field.focus(),MQ.config({autoCommands:"pi sqrt tau alpha beta Gamma",supSubsRequireOperand:!0,charsThatBreakOutOfSupSub:"",autoOperatorNames:opsString,handlers:{enter:mathField=>{advance(mathField.id,1)},downOutOf:mathField=>{advance(mathField.id,1)},upOutOf:mathField=>{advance(mathField.id,-1)},deleteOutOf:(direction,mathField)=>{direction===MQ.L&&deleteField(mathField.id)},edit:function(func,interval){let timer;return function(){const context=this,args=arguments;clearTimeout(timer),timer=setTimeout((()=>func.apply(context,args)),interval)}}((function(mathField){scope.userGlobal={};for(const key in valueScope)valueScope.hasOwnProperty(key)&&delete valueScope[key];Object.assign(valueScope,defaultValueScope);for(const id of Object.keys(fields)){const latex=fields[id].field.latex();fields[id].latex=latex,fields[id].expr=cleanLatex(latex)}const lexer=new Lexer(null,!0);lexer.setScope(scope);const newIdents=[];for(const id of Object.keys(fields)){if(!fields[id].expr.includes("="))continue;const assignment=fields[id].expr,callbacks=getCallbacks(id);tracker.setCallback(callbacks.callback),tracker.setSuccessCallback(callbacks.successCallback),tracker.clear(),lexer.setText(assignment),lexer.tokenize();const tokens=lexer.getTokens(),result=new ExpressionParser(tokens).parseExpression();if(void 0!==result){const left=result.mLeft,isFunction=left instanceof CallExpression,ident=isFunction?left.mFunction.mName:left.mName;if(void 0!==scope.builtin[ident]){tracker.error(`cannot overwrite builtin identifier ${ident}`);continue}if(newIdents.includes(ident)){tracker.error(`multiple definitions for ${ident}`);continue}if(scope.userGlobal[ident]={isFunction:isFunction},isFunction){scope.userGlobal[ident].args={};for(let arg of left.mArgs)if(arg instanceof OperatorExpression){if(!(arg.mLeft instanceof NameExpression&&arg.mOperator===TokenType.COLON)){tracker.error("Invalid arguments");continue}if(!(arg.mRight instanceof NameExpression&&scope.builtin[arg.mRight.mName]?.isType)){tracker.error("Invalid type annotation");continue}scope.userGlobal[ident].args[arg.mLeft.mName]=arg.mRight.mName}else{if(!(arg instanceof NameExpression)){tracker.error("Invalid arguments");continue}scope.userGlobal[ident].args[arg.mName]="complex"}}newIdents.push(ident)}}if(!tracker.hasError){lexer.setScope(scope),lexer.setAllowUnboundIdentifiers(!1);for(const id of Object.keys(fields)){const callbacks=getCallbacks(id);tracker.setCallback(callbacks.callback),tracker.setSuccessCallback(callbacks.successCallback);const expr=fields[id].expr;lexer.setText(expr),lexer.tokenize();const tokens=lexer.getTokens();if(tracker.hasError){fields[id].ast=null;continue}const result=new ExpressionParser(tokens).parseExpression();tracker.hasError?fields[id].ast=null:(fields[id].ast=result,tracker.clear())}}for(const id of Object.keys(fields)){const ast=fields[id].ast;null!==ast&&evaluate(ast)}void 0===valueScope.f||tracker.hasError||(plot.clear(),plot.addPlottable(new DomainColoring((z=>valueScope.f.call({z:z})))))}),500)}});class Plot{static modes={PLANE:1,SPHERE:2,CUBE:3};constructor(displayWidth,displayHeight,bounds=null,mode=null,displayWindowInfo){this.gridlineSpacing=1,this.boundsChangedSinceLastDraw=!1,this.displayWindowInfo=this.displayWindowInfo,this.configureWindow(displayWidth,displayHeight,bounds,null===bounds),this.plottables=[],this.polygons=[],this.needsUpdate=!0,this.mode=null===mode?Plot.modes.PLANE:mode,this.camera={alpha:1,beta:0,pitch:.786,roll:0,yaw:.672},this.calculateRotationMatrix()}configureWindow(newWidth=null,newHeight=null,bounds=null){let widthRatio,heightRatio;null===newWidth?(widthRatio=1,heightRatio=1,newWidth=this.dimensions.re,newHeight=this.dimensions.im):void 0===this.dimensions?(widthRatio=1,heightRatio=1):(widthRatio=this.dimensions.re/newWidth,heightRatio=this.dimensions.im/newHeight),this.dimensions=complex(newWidth,newHeight),this.aspect=newHeight/newWidth,this.halfDimensions=this.dimensions.scale(.5);let fitToSquare=!1;if(null===bounds)if(void 0===this.bounds)bounds={xMin:-4,xMax:4,yMin:-4,yMax:4},fitToSquare=!0;else{const centerX=(this.bounds.xMin+this.bounds.xMax)/2,centerY=(this.bounds.yMin+this.bounds.yMax)/2,halfRangeX=this.units.re*heightRatio/2,halfRangeY=this.units.im*widthRatio/2;bounds={xMin:centerX-halfRangeX,xMax:centerX+halfRangeX,yMin:centerY-halfRangeY,yMax:centerY+halfRangeY}}this.bounds=bounds,this.offset=complex((this.bounds.xMax+this.bounds.xMin)/2,(this.bounds.yMax+this.bounds.yMin)/2),this.units=complex(this.bounds.xMax-this.bounds.xMin,this.bounds.yMax-this.bounds.yMin),this.pixelsPerUnit=complex(this.dimensions.re/this.units.re,this.dimensions.im/this.units.im),this.gridlineCount=complex(this.units.re/this.gridlineSpacing,this.units.im/this.gridlineSpacing),fitToSquare&&this.fitBoundsToSquare(),valueScope.realBounds=complex(this.bounds.xMin,this.bounds.xMax),valueScope.imagBounds=complex(this.bounds.yMin,this.bounds.yMax),this.needsUpdate=!0,this.boundsChangedSinceLastDraw=!0,this.displayWindowInfo&&(console.log("Window configuration"),console.log("window bounds",this.bounds),console.log("offset",this.offset),console.log("window size",this.dimensions),console.log("gridline count",this.gridlineCount))}fitBoundsToSquare(){const centerY=(this.bounds.yMin+this.bounds.yMax)/2,halfRangeY=this.units.re*this.aspect/2;this.configureWindow(this.dimensions.re,this.dimensions.im,{xMin:this.bounds.xMin,xMax:this.bounds.xMax,yMin:centerY-halfRangeY,yMax:centerY+halfRangeY})}setCamera(camera){this.camera.alpha=void 0===camera.alpha?this.camera.alpha:camera.alpha,this.camera.beta=void 0===camera.beta?this.camera.beta:camera.beta,this.camera.pitch=void 0===camera.pitch?this.camera.pitch:camera.pitch,this.camera.yaw=void 0===camera.yaw?this.camera.yaw:camera.yaw,this.camera.roll=void 0===camera.roll?this.camera.roll:camera.roll,this.needsUpdate=!0}pan(offset){this.mode===Plot.modes.PLANE?this.configureWindow(null,null,{xMin:this.bounds.xMin+offset.re,xMax:this.bounds.xMax+offset.re,yMin:this.bounds.yMin+offset.im,yMax:this.bounds.yMax+offset.im}):this.setCamera({pitch:Math.max(Math.min(this.camera.pitch+offset.im,.5*Math.PI),-.5*Math.PI),yaw:Math.max(Math.min(this.camera.yaw-offset.re,Math.PI),-Math.PI)})}zoom(factor){const newHalfUnits=this.units.scale(factor/2),center=complex((this.bounds.xMin+this.bounds.xMax)/2,(this.bounds.yMin+this.bounds.yMax)/2);this.configureWindow(null,null,{xMin:center.re-newHalfUnits.re,xMax:center.re+newHalfUnits.re,yMin:center.im-newHalfUnits.im,yMax:center.im+newHalfUnits.im})}state(){const latex=[];for(const id of Object.keys(fields))fields[id].latex&&latex.push(fields[id].latex);return JSON.stringify({camera:this.camera,bounds:this.bounds,expressions:latex,mode:this.mode},null,4)}loadState(state){state=JSON.parse(state),this.setCamera(state.camera),this.configureWindow(null,null,state.bounds),tabSwitch(state.mode-1);for(const id of Object.keys(fields))deleteField(id,!1);for(const expr of state.expressions){const newField=addField(null);fields[newField].field.latex(expr)}}downloadState(){const state=encodeURIComponent(this.state()),tempEl=document.createElement("a");tempEl.setAttribute("href",`data:text/json;charset=utf-8,${state}`),tempEl.setAttribute("download","plot.json"),document.body.appendChild(tempEl),tempEl.click(),tempEl.remove()}uploadState(){const tempEl=document.createElement("input");tempEl.setAttribute("type","file"),tempEl.setAttribute("accept",".json"),tempEl.setAttribute("id","file-selector"),document.body.appendChild(tempEl),tempEl.click(),tempEl.onchange=()=>{const selector=document.querySelector("#file-selector"),files=selector.files;if(files.length<=0)return;const reader=new FileReader;reader.onload=event=>{this.loadState(event.target.result)},reader.readAsText(files.item(0)),selector.parentNode.removeChild(selector)}}unitsToPixels(z){return complex((z.re-this.offset.re)*this.pixelsPerUnit.re+this.halfDimensions.re,-(z.im-this.offset.im)*this.pixelsPerUnit.im+this.halfDimensions.im)}applyCamera(z){return this.mode===Plot.modes.SPHERE?(z=z instanceof Complex?inverseStereoProject(z):matrix(z).transpose(),Matrix.multiply(this.rotationMatrix,z)):this.mode===Plot.modes.CUBE?(z=z instanceof Complex?matrix([z.re,z.im,0]).transpose():matrix(z).transpose(),Matrix.multiply(this.rotationMatrix,z)):z}coordinateTransform(z){return this.mode!==Plot.modes.PLANE&&(z=perspectiveProject(z,this.camera.alpha,this.camera.beta)),this.unitsToPixels(z)}spaceToScreen(z){return this.coordinateTransform(this.applyCamera(z))}pixelsToUnits(z){return complex(z.re/this.pixelsPerUnit.re,-z.im/this.pixelsPerUnit.im)}setMode(mode){this.mode=mode,mode===Plot.modes.PLANE?void 0!==this.savedBounds&&this.configureWindow(null,null,this.savedBounds):(this.savedBounds=this.bounds,this.configureWindow(null,null,{xMin:-2.5,xMax:2.5,yMin:-1.5,yMax:1.5}),this.fitBoundsToSquare()),this.boundsChangedSinceLastDraw=!0,this.needsUpdate=!0}calculateRotationMatrix(){this.rotationMatrix=Matrix.rotationMatrix3D(this.camera.pitch,this.camera.roll,this.camera.yaw)}clear(){this.plottables=[],this.needsUpdate=!0}addPlottable(plottable){this.plottables.push(plottable),this.needsUpdate=!0}drawAxes(){if(this.mode===Plot.modes.PLANE){const xAxisStart=this.spaceToScreen(complex(this.bounds.xMin,0)),xAxisStop=this.spaceToScreen(complex(this.bounds.xMax,0)),yAxisStart=this.spaceToScreen(complex(0,this.bounds.yMin)),yAxisStop=this.spaceToScreen(complex(0,this.bounds.yMax));push(),stroke(0),strokeWeight(1),line(xAxisStart.re,xAxisStart.im,xAxisStop.re,xAxisStop.im),line(yAxisStart.re,yAxisStart.im,yAxisStop.re,yAxisStop.im),pop()}}drawGridlines(){const minBound=x=>floor(x/this.gridlineSpacing)*this.gridlineSpacing,minBoundX=minBound(this.bounds.xMin),minBoundY=minBound(this.bounds.yMin);push(),stroke(200),strokeWeight(1);for(let i=0;i<this.gridlineCount.im+1;i++){const y=minBoundY+i*this.gridlineSpacing,start=this.unitsToPixels(complex(this.bounds.xMin,y)),end=this.unitsToPixels(complex(this.bounds.xMax,y));line(start.re,start.im,end.re,end.im)}for(let i=0;i<this.gridlineCount.re+1;i++){const x=minBoundX+i*this.gridlineSpacing,start=this.unitsToPixels(complex(x,this.bounds.yMin)),end=this.unitsToPixels(complex(x,this.bounds.yMax));line(start.re,start.im,end.re,end.im)}pop()}draw(){background(255),this.drawGridlines(),this.drawAxes(),this.polygons=[];for(let plottable of this.plottables)plottable.update(),this.polygons=this.polygons.concat(plottable.getPolygons());this.mode!==Plot.modes.PLANE&&this.polygons.sort(((poly1,poly2)=>this.applyCamera(poly2.centroid).get(1,0)-this.applyCamera(poly1.centroid).get(1,0))),push();for(let poly of this.polygons)if(1===poly.vertices.length){fill(0),noStroke();const point=this.coordinateTransform(this.applyCamera(poly.vertices[0]));circle(point.re,point.im,1)}else if(2===poly.vertices.length){stroke(0);const point1=this.coordinateTransform(this.applyCamera(poly.vertices[0])),point2=this.coordinateTransform(this.applyCamera(poly.vertices[1]));line(point1.re,point1.im,point2.re,point2.im)}else{poly.outline?stroke(0):noStroke(),fill(poly.fillColor),beginShape();for(let vert of poly.vertices){const point=this.coordinateTransform(this.applyCamera(vert));vertex(point.re,point.im)}endShape(CLOSE)}pop(),this.boundsChangedSinceLastDraw=!1}update(){this.needsUpdate&&(this.mode!==Plot.modes.PLANE&&this.calculateRotationMatrix(),this.draw(),this.needsUpdate=!1)}}class Plottable{static id=0;constructor(){this.id=Plottable.id,Plottable.id++}getPolygons(){}update(){}}class Polygon{constructor(vertices,fillColor,outline=!1){if(this.vertices=vertices,this.fillColor=fillColor,this.outline=outline,vertices[0]instanceof Complex)this.centroid=Euclid.centroid(vertices);else{let totalX=0,totalY=0,totalZ=0;for(let vert of vertices)totalX+=vert[0],totalY+=vert[1],totalZ+=vert[2];this.centroid=[totalX/this.vertices.length,totalY/this.vertices.length,totalZ/this.vertices.length]}}}class DomainColoring extends Plottable{constructor(fn,bounds=null,density=100){super(),this.fn=fn,null===bounds?(this.bounds=plot.bounds,this.fixedBounds=!1):(this.bounds=bounds,this.fixedBounds=!0),this.samples=complex(density,density),this.subdivisions=Math.floor(Math.log(density*density)/Math.log(4)),this.generatePolygons()}generatePolygons(){plot.mode===Plot.modes.PLANE?this.generatePolygonsPlane():plot.mode===Plot.modes.SPHERE?this.generatePolygonsSphere():this.generatePolygonsPlane()}generatePolygonsSphere(){this.polygons=icosphere(4);const normTransform=norm=>25+2/Math.PI*Math.atan(norm)*75,highlightPoles=norm=>{return 100-85*Math.max(0,Math.min(1,.5*(Math.sign(norm-1e3)+1)*((x=norm-1e3)*x*x*(10-15*x+6*x*x))));var x};push(),colorMode(HSB);for(let i=0;i<this.polygons.length;i++){this.polygons[i]=new Polygon(this.polygons[i]);const centroid=this.polygons[i].centroid;this.polygons[i].vertices=[ssub(1,sscale(1.1,ssub(-1,this.polygons[i].vertices[0],centroid)),centroid),ssub(1,sscale(1.1,ssub(-1,this.polygons[i].vertices[1],centroid)),centroid),ssub(1,sscale(1.1,ssub(-1,this.polygons[i].vertices[2],centroid)),centroid)];const output=this.fn(stereographic(centroid)),norm=output.norm();Complex.infinite(output)||Complex.nan(output)?this.polygons[i].fillColor=color(0,0,100):this.polygons[i].fillColor=color((output.arg()+2*Math.PI)%(2*Math.PI)*360/(2*Math.PI),highlightPoles(norm),normTransform(norm))}pop()}generatePolygonsPlane(){let x=this.bounds.xMin,y=this.bounds.yMin;const step=complex((this.bounds.xMax-this.bounds.xMin)/(this.samples.re-1),(this.bounds.yMax-this.bounds.yMin)/(this.samples.im-1));this.polygons=[],push(),colorMode(HSB);for(let i=0;i<this.samples.re-1;i++){for(let j=0;j<this.samples.im-1;j++){const square=[complex(x,y),complex(x+step.re+.01,y),complex(x+step.re+.01,y+step.im+.01),complex(x,y+step.im+.01)],centroid=complex(x+step.re/2,y+step.im/2),output=this.fn(centroid);let color1;color1=Complex.infinite(output)||Complex.nan(output)?color(0,0,100):color((output.arg()+2*Math.PI)%(2*Math.PI)*360/(2*Math.PI),100,(norm=output.norm(),25+.2*Math.floor(2/Math.PI*Math.atan(Math.sqrt(norm))/.2)*75)),this.polygons.push(new Polygon(square,color1)),x+=step.re}x=this.bounds.xMin,y+=step.im}var norm;pop()}getPolygons(){return this.polygons}update(){plot.boundsChangedSinceLastDraw&&!this.fixedBounds&&(this.bounds=plot.bounds,this.generatePolygons())}}function wheelHandler(event){event.preventDefault();const factor=1+Math.tanh(event.deltaY/100)/4;plot.zoom(factor)}let cImage;function tabSwitch(tab){const plane=document.querySelector("#ui-header-plane"),sphere=document.querySelector("#ui-header-sphere"),cube=document.querySelector("#ui-header-cube");0===tab?(plane.style.backgroundColor="white",sphere.style.backgroundColor="lightgray",cube.style.backgroundColor="lightgray",plot.setMode(Plot.modes.PLANE)):1===tab?(plane.style.backgroundColor="lightgray",sphere.style.backgroundColor="white",cube.style.backgroundColor="lightgray",plot.setMode(Plot.modes.SPHERE)):(plane.style.backgroundColor="lightgray",sphere.style.backgroundColor="lightgray",cube.style.backgroundColor="white",plot.setMode(Plot.modes.CUBE))}window.preload=function(){cImage=loadImage("http://localhost:8000/data/grid_3.png")},window.setup=function(){const canvasDiv=document.querySelector("#canvas-div");createCanvas(canvasDiv.offsetWidth,canvasDiv.offsetHeight).parent("canvas-div"),document.querySelector("#canvas-div").onwheel=wheelHandler,plot=new Plot(width,height,null,Plot.modes.SPHERE,!1),tabSwitch(plot.mode-1),lastMouseX=mouseX,lastMouseY=mouseY},window.mouseDragged=function(){0<=mouseX&&mouseX<=width&&0<=mouseY&&mouseY<=height&&(plot.pan(plot.pixelsToUnits(complex(lastMouseX-mouseX,lastMouseY-mouseY))),lastMouseX=mouseX,lastMouseY=mouseY)},window.mousePressed=function(){lastMouseX=mouseX,lastMouseY=mouseY},window.mouseReleased=function(){lastMouseX=0,lastMouseY=0},window.windowResized=function(){document.querySelector("#canvas-div"),resizeCanvas(.75*window.innerWidth,document.querySelector("#ui-container").offsetHeight),plot.configureWindow(width,height)},window.tabSwitch=tabSwitch,window.draw=function(){plot.update()}},{"./evaluator.js":1,"./math/complex.js":2,"./math/fourier.js":3,"./math/geometry.js":4,"./math/icosphere.js":5,"./math/matrix.js":6,"./math/projection.js":7,"./math/rvector.js":8,"./parsing/errors.js":9,"./parsing/latex_convert.js":10,"./parsing/pratt/expression_parser.js":11,"./parsing/pratt/expressions.js":12,"./parsing/pratt/lexer.js":13,"./parsing/pratt/tokentype.js":18,"./scope.js":20}]},{},[21]);